设计模式：
    创建型：
        单例：
            确保一个类只有一个实例，并提供该实例的全局访问点
            实现:
                一个私有构造函数：确保不能通过构造函数创建对象实例
                一个私有静态变量
                一个公有静态函数：返回唯一的私有静态变量
        工厂：
            简单工厂：
                在创建一个对象时不暴露内部细节，并提供一个创建对象的通用接口
            工厂模式：
                子类中创建对象     继承
            抽象工厂：
                提供一个接口，用于创建相关的对象，这些对象是相关的，必须一起创建出来      组合
        生成器：
            封装一个对象的构造过程，允许按步骤构造
        原型模式：
            使用原型实例指定要创建的类型，通过复制这个原型来创建对象
    行为型：
        责任链：
            使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到
            有一个对象处理它为止。
        命令：
            将命令封装成对象中：
                使用命令来参数化其他对象
                将命令放入队列中进行排队
                将命令的操作记录到日志中
                支持可撤销的操作
        解释器：
            为语言创建解释器，通常由语言的语法和语法分析来定义
        迭代器：
            提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示
        中介者：
            集中相关对象之间复杂的沟通和控制方式
        备忘录：
            在不违反封装的情况下获取对象的内部状态，从而在需要时可以将对象恢复到最初状态
        观察者：
            定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会受到通知并且自动更新状态
            主题是被观察的对象，其所有依赖者成为观察者
        状态：
            允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类
        策略：
            定义一系列算法，封装每个算法，并使它们可以互换
            策略模式可以让算法独立于使用它的客户端
            状态模式是通过状态转移来改变Context所组合的State对象，而策略模式是通过Context本身的决策来改变组合的Strategy对象
            状态模式主要用来解决状态转移的问题，档状态发生转移了，Context对象就会改变它的行为
            策略模式主要是用来封装一组可相互代替的算法族，并且可以根据需要动态的去替换Context使用的算法
        模板：
            定义算法框架，并将一些步骤的实现延迟到子类
            通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构
        访问者：
            为一个对象结构(比如组合结构)增加新能力
        空对象：
            使用什么都不做的空对象来代替null
    结构型：
        适配器：
            把一个类接口转换成另一个用户需要的接口
        桥接：
            将抽象与实现分离开来，使他们可以独立变化
        组合：
            将对象组合成树形结构来表示‘整体/部分’层次关系，允许用户以相同的方式处理单独对象和组合对象
        装饰：
            为对象动态添加功能
            设计原则：类对扩展开放，对修改关闭
        外观：
            提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用
        享元：
            利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的
            eg：基本类型的包装类利用缓存来加速大量小对象的访问时间
        代理：
            控制对其他对象的访问
            远程代理：
                控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已编码的请求
            虚拟代理：
                根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问
            保护代理：
                按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限
            智能代理：
                取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；档第一次引用一个对象时，将它装入内存；在
                访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。